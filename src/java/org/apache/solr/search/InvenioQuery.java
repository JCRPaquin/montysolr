package org.apache.solr.search;

import org.apache.lucene.search.Query;
import org.apache.lucene.search.Searcher;
import org.apache.lucene.search.Similarity;
import org.apache.lucene.search.TermQuery;
import org.apache.lucene.search.Weight;
import org.apache.lucene.util.ToStringUtils;

import java.io.IOException;
import java.util.Map;
import java.util.Set;

import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.Term;
import org.apache.solr.common.params.SolrParams;
import org.apache.solr.request.SolrQueryRequest;
import org.apache.solr.search.InvenioQParserPlugin;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class InvenioQuery extends Query {

	public static final Logger log = LoggerFactory
			.getLogger(InvenioQuery.class);

	private float boost = 1.0f; // query boost factor
	Query query;
	SolrParams localParams;
	SolrQueryRequest req;
	Map<Integer, Integer> recidToDocid = null;

	public InvenioQuery(TermQuery query, SolrQueryRequest req,
			SolrParams localParams, Map<Integer, Integer> recidToDocid) {
		this.query = query;
		this.localParams = localParams;
		this.req = req;
		this.recidToDocid = recidToDocid;

	}

	/**
	 * Sets the boost for this query clause to <code>b</code>. Documents
	 * matching this clause will (in addition to the normal weightings) have
	 * their score multiplied by <code>b</code>.
	 */
	public void setBoost(float b) {
		query.setBoost(b);
	}

	/**
	 * Gets the boost for this clause. Documents matching this clause will (in
	 * addition to the normal weightings) have their score multiplied by
	 * <code>b</code>. The boost is 1.0 by default.
	 */
	public float getBoost() {
		return query.getBoost();
	}

	/**
	 * Expert: Constructs an appropriate Weight implementation for this query.
	 *
	 * <p>
	 * Only implemented by primitive queries, which re-write to themselves.
	 */
	public Weight createWeight(Searcher searcher) throws IOException {

		return new InvenioWeight(this, localParams, req, recidToDocid);
	}

	/**
	 * Expert: Constructs and initializes a Weight for a top-level query.
	 */
	public Weight weight(Searcher searcher) throws IOException {
		Query query = searcher.rewrite(this);
		Weight weight = query.createWeight(searcher);
		float sum = weight.sumOfSquaredWeights();
		float norm = getSimilarity(searcher).queryNorm(sum);
		if (Float.isInfinite(norm) || Float.isNaN(norm))
			norm = 1.0f;
		weight.normalize(norm);
		return weight;
	}

	/**
	 * Expert: called to re-write queries into primitive queries. For example, a
	 * PrefixQuery will be rewritten into a BooleanQuery that consists of
	 * TermQuerys.
	 */
	public Query rewrite(IndexReader reader) throws IOException {
		Query rewritten = query.rewrite(reader);
		if (rewritten != query) {
			InvenioQuery clone = (InvenioQuery) this.clone();
			clone.query = rewritten;
			return clone;
		} else {
			return this;
		}
	}

	/**
	 * Expert: called when re-writing queries under MultiSearcher.
	 *
	 * Create a single query suitable for use by all subsearchers (in 1-1
	 * correspondence with queries). This is an optimization of the OR of all
	 * queries. We handle the common optimization cases of equal queries and
	 * overlapping clauses of boolean OR queries (as generated by
	 * MultiTermQuery.rewrite()). Be careful overriding this method as
	 * queries[0] determines which method will be called and is not necessarily
	 * of the same type as the other queries.
	 */
	public Query combine(Query[] queries) {
		return query.combine(queries);

	}

	/**
	 * Expert: adds all terms occurring in this query to the terms set. Only
	 * works if this query is in its {@link #rewrite rewritten} form.
	 *
	 * @throws UnsupportedOperationException
	 *             if this query is not yet rewritten
	 */
	public void extractTerms(Set terms) {
		query.extractTerms(terms);
	}

	/**
	 * Expert: Returns the Similarity implementation to be used for this query.
	 * Subclasses may override this method to specify their own Similarity
	 * implementation, perhaps one that delegates through that of the Searcher.
	 * By default the Searcher's Similarity implementation is returned.
	 */
	public Similarity getSimilarity(Searcher searcher) {
		return searcher.getSimilarity();
	}

	/** Prints a user-readable version of this query. */
	public String toString(String s) {
		StringBuffer buffer = new StringBuffer();
		buffer.append("<");
		Term t = ((TermQuery) query).getTerm();
		if (t.field().length() > 0 ) {
			buffer.append(t.field());
			buffer.append("|");
		}
		buffer.append(t.text());
		//buffer.append(query.toString(s));
		buffer.append(">");
		buffer.append(ToStringUtils.boost(getBoost()));
		return buffer.toString();
	}

	/** Returns true iff <code>o</code> is equal to this. */
	public boolean equals(Object o) {
		if (o instanceof InvenioQuery) {
			InvenioQuery fq = (InvenioQuery) o;
			return (query.equals(fq.query) && getBoost() == fq.getBoost());
		}
		return false;
	}

	/** Returns a hash code value for this object. */
	public int hashCode() {
		return query.hashCode() ^ Float.floatToRawIntBits(getBoost());
	}

	public String getInvenioQuery() {
		String qfield = ((TermQuery) query).getTerm().field();
		String qval = ((TermQuery) query).getTerm().text();
		if (qfield.length() > 0) {
			qval = qfield + ":" + qval;
		}
		if (qval.substring(0, 1).equals("\"/")) {
			qval = qval.substring(1, qval.length()-1);
		}
		return qval;
	}
}

