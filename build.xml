<project name="montysolr" default="usage">

	<description>Java extensions for Invenio - Java search engine made python-friendly</description>


	<!--
  ==================================================================
     Configuration section
  ==================================================================
  -->


	<property name="montysolr.home" location="." />
	<property name="src.dir.java" location="src/java" />
	<property name="src.dir.python" location="src/python" />
	<property name="build.dir" value="build" />
	<property name="dist.dir" value="build/dist" />
	<property name="classes.dir" value="bin" />
	<property name="jar.dir" value="${build.dir}/jar" />

	<property file="build.properties" />


	<!-- these are now defined in the properties file
    <property name="jcc"           value="jcc.__main__" />
    <property name="solr_home"     value="/x/dev/workspace/apache-solr-1.4.1"/>
    <property name="python"        value="python"/>
    //-->

	<property name="solr.home" location="${solr_home}"/>
	<property name="webdist.home" location="${webdist}" />
	<property name="lib.dir" value="lib" />
	<property name="app.name" value="montysolr_java" />
	<property name="app.version" value="0.1" />
	<property name="jar.dir" value="${jar.dir}/${app.name}-${app.version}.jar" />
	<property name="jar.suffix" value="${app.name}-${app.version}.jar" />
	<property name="app.solr.name" value="solr_java" />
	<property name="app.solr.version" value="0.1" />
	<property name="ddash" value="--" />


	<!-- standard arguments for running the Solr -->
	<property name="run.solr.jvmargs" value="-d64 -Xmx1024m -Dmontysolr.max_workers=4 -Dmontysolr.max_threads=200" />
	<property name="run.solr.args" value="" />

	<!-- these will be used when running tests and command line montysolr
	     you can set them as:
	     export MONTYSOLR_JVMARGS=-Djava.util.logging.config.file=./example/etc/test.logging.properties

	     If you are using python c-extensions, make sure they are compatible with the
	     java - if your java starts in 64bit mode, also the extensions must be available in 64bit
	     By default, we run in 64bit mode: -d64
     //-->
	<property environment="env"/>
	<property name="subant.jvmargs" value="" />
	<property name="subant.args" value="" />
	<property name="subant.newenvironment" value="true" />
	<property name="env.MONTYSOLR_JVMARGS" value="${subant.jvmargs}"/>
	<property name="env.MONTYSOLR_ARGS" value="${subant.args}"/>
	<property name="env.MONTYSOLR_NEWENVIRONMENT" value="${subant.newenvironment}"/>
	<property name="env.PYTHONPATH" value=""/>

	<!--
    these classes must be made available/known to JCC when we compile the wrapper
    They will be made visible to Python, but are also used for generation of the jars.
     -->
	<property name="montysolr.classes" value="
		invenio.montysolr.jni.MontySolrBridge
		invenio.montysolr.jni.PythonBridge
		invenio.montysolr.jni.PythonMessage
		invenio.montysolr.util.InvenioBitSet
		invenio.montysolr.JettyRunner
		org.apache.solr.util.DictionaryCache
		" />
	<property name="jcc.build" value="${montysolr.classes}" />
	<property name="jcc.packages" value="
	--package ch.cern.invenio.utils
	"/>


	<!--
    _build variables are there to add extra classes to the wrapper - some packages (either in lucene or for montysolr)
    are not usable/visible, unless also these classes are present. So this is here to add these extra components to the build.
    I tried registerining packages only, but it didn't work for v2.9, so i am listing classes directly
    -->
	<property name="jcc.build_also" value="java.util.ArrayList
		java.lang.Float
		java.lang.System
		java.lang.String
		org.apache.solr.request.SolrQueryRequest
		org.apache.solr.request.SolrQueryResponse" />


	<!--Needed only if you want to regenerate InvenioQueryParser syntax,
        which is probably not what you need to do -->

	<property name="javacc.home" value="/some/path/javacc-5.0" />

	<!-- retrieves the location of the jcc and stores in inside jcc_egg -->
	<exec executable="${python}" failonerror="true" outputproperty="jcc_egg" >
		<arg value="-c"/>
		<arg value="import os, jcc; print os.path.dirname(os.path.dirname(jcc.__file__))" />
	</exec>


	<import file="common-build.xml"/>
	<path id="classpath">
		<path refid="common.classpath"/>
	</path>
	<path id="test.classpath">
		<path refid="common.test.classpath"/>
	</path>
	<path id="junit.classpath">
		<path refid="common.junit.classpath"/>
	</path>



	<!--
      ==================================================================
         Initialization & maintenance stuff
      ==================================================================
      -->

	<target name="compile-test" depends="common.compile-test" />

	<target name="config" depends="init">
		<property name="my.montysolr.jar" value="${jar.dir}/${jar.suffix}" />

	</target>

	<!-- Default target: usage.  Prints out instructions. -->
	<target name="usage"
	          description="Prints out instructions">
		<echo message="Welcome to the MontySolr project!" />
		<echo message="Use 'ant build-all' to compile MontySolr and prepare demos." />
		<echo message="Use 'ant run' to run the example." />
		<echo message="Use 'ant run-daemon' to run the example with logging." />

		<echo message="And for developers:"/>
		<echo message="Use 'ant clean' to clean compiled files." />
		<echo message="Use 'ant compile' to compile the Java source code." />
		<echo message="Use 'ant build' to compile only MontySolr as a Python module." />
		<echo message="Use 'ant build-solr' to compile only Solr as a Python module." />
		<echo message="TODOs:" />
		<echo message="Use 'ant automatic-install' to install everything incl dependencies." />
		<echo message="Use 'ant package' to generate zip, tgz, and maven artifacts for distribution." />
		<echo message="Use 'ant test' to run unit tests." />
	</target>




	<!-- this is needed for all targets -->
	<target name="init" depends="check_properties,die_unless_propertiesOK,check-solr-location">
		<mkdir dir="${build.dir}" />
		<mkdir dir="${dist.dir}" />
		<mkdir dir="${classes.dir}" />
		<mkdir dir="${build.dir}/jar" />

		<exec executable="${python}" failonerror="false" errorproperty="test_import_errors" >
			<arg value="-c"/>
			<arg value="import jcc; import lucene" />
		</exec>

		<condition property="import_ok">
			<equals arg1="${test_import_errors}" arg2=""/>
		</condition>

		<fail unless="import_ok" message="${test_import_errors}${line.separator}Please install the required Python modules first (jcc, lucene)" />


		<exec executable="${python}" failonerror="true" outputproperty="webdist.webapp">
			<arg value="-c"/>
			<arg value="import os;d='${webdist.home}';print os.path.exists(d+'/webapps/solr.war') and d+'/webapps/solr.war' or d+'/webapps'" />
		</exec>


	</target>


	<target name="check_properties">
		<condition property="propertiesOK">
			<and>
				<isset property="solr_home" />
				<isset property="webdist" />
				<isset property="python" />
				<isset property="jcc" />
			</and>
		</condition>
	</target>

	<target name="die_unless_propertiesOK" unless="propertiesOK">
		<echo>The properties of the project are not set correctly. Copy "build.properties.default" -> "build.properties" and edit the new file if necessary.</echo>
		<fail />
	</target>



	<target name="clean" >
		<delete dir="${build.dir}" />
		<delete dir="${classes.dir}" />
		<mkdir dir="${classes.dir}"/>
	</target>

	<target name="default">

	</target>

	<!--
      ==================================================================
         Compilation section for jars
      ==================================================================
      -->

	<!-- this is needed for building targets -->
	<target name="config-build" depends="config,check-solr-location,check-lucene-jars,set-jar-paths" >
	</target>


	<target name="set-jar-paths">
		<!--
                      The part below will discover all the paths inside the directory (for the
                      given pattern) and the property with .path end element will look like
                      path1 [dash][dash]jar path2 [dash][dash]jar path3....

                      However, this is suboptimal for cases, when there are two versions of the
                      jar file in the folder, for example:
                       solr-core-1.4.1.jar
                       solr-core-1.4.2-dev.jar

                  We include them all. TODO: pick the newest file only
                  -->
		<path id="solr.core.path">
			<fileset dir="${solr.real.location}/dist" id="solr.core.jar" >
				<filename name="*solr-core-*.jar"/>
			</fileset>
		</path>
		<pathconvert property="solr.core.jar.string" pathsep=" --jar ">
			<path refid="solr.core.path" />
		</pathconvert>

		<path id="solr.sorlj.path">
			<fileset dir="${solr.real.location}/dist" id="solr.solrj.jar" >
				<filename name="*solr-solrj-*.jar"/>
			</fileset>
		</path>
		<pathconvert property="solr.solrj.jar.string" pathsep=" --jar ">
			<path refid="solr.sorlj.path" />
		</pathconvert>


		<path id="montysolr.classpath">
			<fileset dir="${jar.dir}" includes="**/*.jar" />
			<fileset dir="${solr.real.location}/dist" includes="**/*.jar" />
			<fileset dir="${webdist.home}/lib" includes="**/*.jar" />
			<fileset dir="${lib.dir}" includes="**/*.jar" />
		</path>
	</target>

	<!-- Compiles all java classes -->
	<target name="compile" depends="config-build">
		<javac srcdir="${src.dir.java}" destdir="${classes.dir}"
			classpathref="montysolr.classpath"
		    classpath="${jcc_egg}/jcc/classes"
		/>
	</target>


	<!-- create a montysolr.jar that we can include and that contains our extra code -->
	<target name="build-jar" depends="config-build,compile">
		<mkdir dir="${jar.dir}" />
		<jar destfile="${my.montysolr.jar}" filesetmanifest="mergewithoutmain">
			<manifest>
				<attribute name="Built-By" value="${user.name}" />
				<attribute name="Main-Class" value="${jcc.build}" />
				<attribute name="Class-Path" value="." />
			</manifest>
			<fileset dir="${classes.dir}" />
		</jar>
	</target>



	<!--
  ==================================================================
     Jetty (JavaVM) embedded in Python - this becomes obsolete, but
     does not need be. The same code works in Python (and in fact,
     is used when we run python unittests). But I do concentrate on
     the Python-inside-Java mode now.
  ==================================================================
  -->

	<!-- Builds jar and also compile Java-Pyhon wrapper - this is all you need to run Solr inside Python; cleans everything before starting -->
	<target name="montysolr-jetty-build-clean"
		depends="clean,montysolr-jetty-build"/>

	<!-- Builds jar and also compile Java-Pyhon wrapper - this is all you need to run Solr inside Python -->
	<target name="montysolr-jetty-build"
		depends="config-build,build-jar,montysolr-jetty-egg-compilation,unzip-egg">
	</target>


	<target name="montysolr-jetty-egg-compilation" depends="build-jar">
		<mkdir dir="${build.dir}" />
		<delete dir="${build.dir}/build" failonerror="no" />

		<exec executable="${python}" dir="${build.dir}" failonerror="true">
			<arg line="${jcc}" />
			<arg value="${ddash}shared" />
			<!--<arg value="${ddash}no-generics" />-->
			<arg line="${jcc.build_also}" />
			<arg line="${jcc.build}" />
			<arg value="${ddash}python" />
			<arg value="${app.name}" />
			<arg value="${ddash}build" />
			<arg value="${ddash}classpath" />
			<arg value="${toString:montysolr.classpath}${path.separator}../${my.montysolr.jar}" />
			<arg value="${ddash}include" />
			<arg value="../${my.montysolr.jar}" />
			<arg value="${ddash}bdist" />
			<arg value="${ddash}version" />
			<arg value="${app.version}" />
		</exec>
	</target>


	<!--
  ==================================================================
     Testing Python Eggs
  ==================================================================
  -->
	<target name="before-unzip">
		<delete dir="${build.dir}/${app.name}.egg-info" failonerror="no" />
		<delete dir="${build.dir}/EGG-INFO" failonerror="no" />
	</target>

	<!-- Unzip the egg into python-test to be loadable -->
	<target name="unzip-egg" depends="config-build,before-unzip">
		<delete dir="${dist.dir}/${app.name}" failonerror="yes" />
		<unzip dest="${dist.dir}" overwrite="yes">
			<fileset dir="${dist.dir}">
				<include name="${app.name}*.egg" />
			</fileset>
		</unzip>
		<move file="${dist.dir}/EGG-INFO" tofile="${dist.dir}/${app.name}.egg-info" />

		<!-- write the current classpath into a text file -->
		<echo file="${dist.dir}/${app.name}/classpath">${toString:montysolr.classpath}</echo>
	</target>



	<!-- Just a basic test to verify that our montysolr package is correctly compiled and contains the necessary classes -->
	<target name="test-egg" depends="config-build">
		<exec executable="${python}" dir="${dist.dir}" failonerror="true">
			<arg value="-c" />
			<arg value="import ${app.name} as X;X.initVM(X.CLASSPATH+'${path.separator}${toString:montysolr.classpath}',vmargs='-Dsolr.solr.home=/x/dev/workspace/test-solr/solr,-Dsolr.data.dir=/x/dev/workspace/test-solr/solr/data');assert (X.__file__ == 'montysolr/__init__.pyc');print X.JettyRunner,X.JettyRunner.main(('solr.home', '/x/dev/workspace/test-solr/solr'))" />
		</exec>
	</target>



	<!--
	==================================================================
     Embedding Python VM in Java VM
    ==================================================================
    -->


	<target name="build-all" depends="examples,build-solr,build"
		description="Build Python egg for Solr, and sorlpie egg to be embedded inside Java VM, this is what you need to run Invenio inside Solr"/>

	<target name="build" depends="config-build,compile-montysolr-egg,unzip-egg"
		   description="Build MontySolr separately"/>


	<target name="build-test" depends="build,run" />

	<!-- Compile egg for embedding into Java VM -->
	<target name="compile-montysolr-egg" depends="build-jar">
		<mkdir dir="${build.dir}" />
		<delete dir="${build.dir}/build" failonerror="no" />

		<exec executable="${python}" dir="${build.dir}" failonerror="true">
			<env key="PYTHONPATH" value="${src.dir.python}${path.separator}../${dist.dir}${path.separator}${env.PYTHONPATH}" />

			<!-- this is mac specific, i will yet have to find out how to make it os-specific -->
			<env key="JCC_LFLAGS" value="-framework${path.separator}JavaVM${path.separator}-framework${path.separator}Python" />

			<arg line="${jcc}" />
			<arg value="${ddash}shared" />
			<!--<arg value="${ddash}no-generics" />-->
			<arg value="${ddash}version" />
			<arg value="${app.version}" />
			<arg line="${jcc.build}" />
			<arg line="${jcc.build_also}" />
			<arg value="${ddash}import"/>
			<arg value="lucene" />
			<arg value="${ddash}import" />
			<arg value="${app.solr.name}" />

			<!--
			<arg value="${ddash}jar" />
            <arg value="../${my.montysolr.jar}" />
			-->
			<arg line="${jcc.packages}" />
			<arg value="${ddash}package" />
			<arg line="org.apache.solr.request ${ddash}package java.lang" />
			<arg value="${ddash}classpath" />
			<arg value="${toString:montysolr.classpath}${path.separator}../${my.montysolr.jar}:${path.separator}${jcc_egg}/jcc/classes/" />
			<arg value="${ddash}include" />
			<arg value="../${my.montysolr.jar}" />
			<arg value="${ddash}python" />
			<arg value="${app.name}" />
			<arg value="${ddash}build" />
			<arg value="${ddash}bdist" />

			<!-- this can be activated if i want to distribute python together with the jcc, python code
                 will be copied into the extension folder
            <arg value="${ddash}module" />
            <arg value="${src.dir.python}" />
            -->
		</exec>
	</target>



	<target name="build-solr" depends="config-build,compile-solr-egg,unzip-solr"
	           description="Build separately the Python egg of Solr"/>


	<target name="compile-solr-egg" depends="config-build">
		<mkdir dir="${build.dir}" />
		<delete dir="${build.dir}/build" failonerror="no" />

		<echo message="You can watch Monty Python, this takes a while..." />

		<exec executable="${python}" dir="${build.dir}" failonerror="true">
			<env key="PYTHONPATH" value="${src.dir.python}${path.separator}${env.PYTHONPATH}" />

			<!-- this is mac specific, i will yet have to find out how to make it os-specific,
			     but it makes no problems to Ubuntu/SLC linux os'es so far -->
			<env key="JCC_LFLAGS" value="-framework${path.separator}JavaVM${path.separator}-framework${path.separator}Python" />


			<arg line="${jcc}" />
			<arg value="${ddash}shared" />
			<!--<arg value="${ddash}no-generics" />-->
			<arg value="${ddash}version" />
			<arg value="${app.solr.version}" />
			<arg value="${ddash}import"/>
			<arg value="lucene" />
			<arg line="${ddash}jar ${solr.core.jar.string}" />
			<arg line="${ddash}jar ${solr.solrj.jar.string}" />
			<arg value="${ddash}classpath" />
			<arg value="${toString:montysolr.classpath}${path.separator}${jcc_egg}/jcc/classes/" />
			<arg value="${ddash}package" />
			<arg value="java.lang" />
			<arg value="${ddash}python" />
			<arg value="${app.solr.name}" />
			<arg value="${ddash}build" />
			<arg value="${ddash}bdist" />
			<arg line="${ddash}exclude org.apache.solr.search.FunctionQParser" />
		</exec>
	</target>


	<target name="unzip-solr">
		<!-- retrieves the location of the jcc -->
		<exec executable="${python}" failonerror="true" outputproperty="_tmp_solr_err" dir="${build.dir}/dist">
			<arg value="-c"/>
			<arg value="import os,glob; print os.path.abspath(glob.glob('./${app.solr.name}*.egg')[0])" />
		</exec>

		<delete dir="${dist.dir}/${app.solr.name}.egg-info" failonerror="no" />
		<delete dir="${dist.dir}/${app.solr.name}" failonerror="no" />

		<unzip dest="${dist.dir}" overwrite="yes">
			<fileset dir="${dist.dir}">
				<include name="${app.solr.name}*.egg" />
			</fileset>
		</unzip>
		<move file="${dist.dir}/EGG-INFO" tofile="${dist.dir}/${app.solr.name}.egg-info" />
	</target>


	<target name="run-bare" depends="config-build,compile">
		<echo>
Running montysolr as:
========
java -cp '${jcc_egg}/jcc/classes${path.separator}${classes.dir}${path.separator}${toString:montysolr.classpath}'
	-Dsolr.solr.home=${webdist.home}/solr -Dsolr.data.dir=${webdist.home}/solr/data
	-Djava.library.path=${jcc_egg}
	${env.MONTYSOLR_JVMARGS}
	--webroot ${webdist.webapp}
	--context /solr
	${env.MONTYSOLR_ARGS}
		</echo>
		<java classpath="${jcc_egg}/jcc/classes${path.separator}${classes.dir}"
			classpathref="montysolr.classpath"
			fork="true"
			newenvironment="${env.MONTYSOLR_NEWENVIRONMENT}"
			classname="invenio.montysolr.JettyRunnerPythonVM"
			>

			<env key="PYTHONPATH" path="${python_path}${path.separator}${dist.dir}${path.separator}${src.dir.python}${path.separator}${env.PYTHONPATH}" />
			<jvmarg line="-Dsolr.solr.home=${webdist.home}/solr -Dsolr.data.dir=${webdist.home}/solr/data"/>
			<jvmarg line="-Djava.library.path=${jcc_egg}"/>
			<jvmarg line="${env.MONTYSOLR_JVMARGS}"/>
			<arg value="--webroot"/>
			<arg value="${webdist.webapp}"/>
			<arg value="--context"/>
			<arg value="/solr"/>
			<arg line="${env.MONTYSOLR_ARGS}"/>
		</java>

	</target>

	<target name="run-daemon" depends="config" >
		<exec executable="ant" failonerror="true" dir="${montysolr.home}">
			<env key="MONTYSOLR_MAX_WORKERS" value="4" />
			<env key="MONTYSOLR_JVMARGS" value="${run.solr.jvmargs} ${env.MONTYSOLR_JVMARGS} -Djava.util.logging.config.file=${webdist.home}/etc/logging.properties" />
			<env key="MONTYSOLR_ARGS" value="${run.solr.args} ${env.MONTYSOLR_ARGS} --daemon" />
			<arg value="run-bare"/>
		</exec>
	</target>

	<target name="run" depends="config"
        description="Starts MontySolr">

		<exec executable="ant" failonerror="true" dir="${montysolr.home}">
			<env key="MONTYSOLR_MAX_WORKERS" value="4" />
			<env key="MONTYSOLR_JVMARGS" value="${run.solr.jvmargs} ${env.MONTYSOLR_JVMARGS} " />
			<env key="MONTYSOLR_ARGS" value="${run.solr.args} ${env.MONTYSOLR_ARGS} --daemon"/>
			<arg value="run-bare"/>
		</exec>
	</target>




	<!--
    ====================================================================
                   Query Parser for Invenio syntax
    ====================================================================
    -->

	<target name="javacc-clean">
		<delete>
			<fileset dir="${src.dir.java}/org/apache/lucene/queryParser" includes="*.java">
				<containsregexp expression="Generated.*By.*JavaCC"/>
				<exclude name="ParseException.java"/>
			</fileset>
		</delete>
	</target>

	<target name="javacc-init" depends="javacc-uptodate-check, javacc-notice">
	</target>

	<target name="javacc-uptodate-check">
		<available
		    property="javacc.present"
		    classname="org.javacc.parser.Main"
		    classpath="${javacc.home}/bin/lib/javacc.jar"
		    />
		<uptodate property="javacc.files.uptodate">
			<srcfiles dir="${src.dir.java}" includes="**/*.jj" />
			<mapper type="glob" from="*.jj" to="*.java"/>
		</uptodate>
	</target>

	<target name="javacc-notice" unless="javacc.files.uptodate">
		<echo>
	      One or more of the JavaCC .jj files is newer than its corresponding
	      .java file.  Run the "javacc" target to regenerate the artifacts.
	    </echo>
	</target>

	<target name="javacc-check">
		<fail unless="javacc.present">
	      ##################################################################
	      JavaCC not found.
	      JavaCC Home: ${javacc.home}
	      JavaCC JAR: ${javacc.jar}

	      Please download and install JavaCC from:

	      &lt;http://javacc.dev.java.net&gt;

	      Then, create a build.properties file either in your home
	      directory, or within the Lucene directory and set the javacc.home
	      property to the path where JavaCC is installed. For example,
	      if you installed JavaCC in /usr/local/java/javacc-3.2, then set the
	      javacc.home property to:

	      javacc.home=/usr/local/java/javacc-3.2

	      If you get an error like the one below, then you have not installed
	      things correctly. Please check all your paths and try again.

	      java.lang.NoClassDefFoundError: org.javacc.parser.Main
	      ##################################################################
	    </fail>

	</target>

	<target name="javacc-InvenioQueryParser-rebuild" depends="javacc-clean, javacc-InvenioQueryParser" if="javacc.present">
		<antcall target="compile">
		</antcall>
	</target>

	<target name="javacc-InvenioQueryParser" depends="javacc-init,javacc-check" if="javacc.present">
		<sequential>
			<invoke-javacc target="${src.dir.java}/org/apache/lucene/queryParser/InvenioQueryParser.jj"
	                     outputDir="${src.dir.java}/org/apache/lucene/queryParser"/>

			<!-- Change the inccorrect public ctors for QueryParser to be protected instead -->
			<replaceregexp file="${src.dir.java}/org/apache/lucene/queryParser/InvenioQueryParser.java"
	             byline="true"
	             match="public InvenioQueryParser\(CharStream "
	             replace="protected InvenioQueryParser(CharStream "/>
			<replaceregexp file="${src.dir.java}/org/apache/lucene/queryParser/InvenioQueryParser.java"
	             byline="true"
	             match="public InvenioQueryParser\(InvenioQueryParserTokenManager "
	             replace="protected InvenioQueryParser(InvenioQueryParserTokenManager "/>

		</sequential>
	</target>

	<macrodef name="invoke-javacc">
		<attribute name="target"/>
		<attribute name="outputDir"/>
		<sequential>
			<mkdir dir="@{outputDir}"/>
			<javacc
	          target="@{target}"
	          outputDirectory="@{outputDir}"
	          debugTokenManager="${javacc.debug.tokenmgr}"
	          debugParser="${javacc.debug.parser}"
	          debuglookahead="${javacc.debug.lookahead}"
	          javacchome="${javacc.home}"
	      />
			<fixcrlf srcdir="@{outputDir}" includes="*.java">
				<containsregexp expression="Generated.*By.*JavaCC"/>
			</fixcrlf>
		</sequential>
	</macrodef>




	<!--
    ====================================================================
                   Installation goodies
    ====================================================================
    -->

	<target name="examples"
          description="Assembels MontySolr example demos (from Solr and our sources)"
          depends="check-solr-location,download-solr,build-solr-example">

		<apply executable="ant" type="dir" dir="${montysolr.home}">

			<arg line="assemble-example" />
			<arg line="-Dassemble.source"/>
			<arg value="${solr.real.location}/example" />
			<arg line="-Dassemble.target"/>
			<srcfile />

			<dirset dir="${montysolr.home}">
				<include name="examples/*"/>
			</dirset>
		</apply>


		<echo>
	    The MontySolr examples were assembled from the original Solr example distribution
		(${solr.home}/example)
		See ${montysolr.home}/examples/README.txt for instructions on how to
		run the demos.
		</echo>
	</target>

	<target name="assemble-example" depends="config-build">
		<!-- called only from the examples target, automatically -->
		<copy todir="${assemble.target}" overwrite="false">
			<fileset dir="${assemble.source}">
				<include name="**/**" />
			</fileset>
		</copy>
		<echo>
	      Copied from ${assemble.source} to ${assemble.target}
	   </echo>
	</target>




	<!-- this target sets the location of the solr, if not present, we'll assume build/solr-download/apache-solr-${solr.version}/solr
	   The property may also be set by a download-solr task
	 -->
	<target name="check-solr-location" >
		<condition property="solr.real.location" value="${solr.home}">
			<and>
				<available file="${solr.home}/example/start.jar"/>
				<available file="${solr.home}/lib/commons-io-1.4.jar"/>
			</and>
		</condition>

		<condition property="solr.real.location" value="${build.dir}/solr-download/apache-solr-${solr.version}/solr">
			<and>
				<available file="${build.dir}/solr-download/apache-solr-${solr.version}/solr/example/start.jar"/>
				<available file="${build.dir}/solr-download/apache-solr-${solr.version}/solr/lib/commons-io-1.4.jar"/>
			</and>
		</condition>

		<echo message="Did we find real solr? Path=${solr.real.location}" level="verbose" />
	</target>


	<!-- Download the solr binary distribution, unless it was already downloaded (if solr.real.location is
         set, then we know solr was already downloaded/exists) -->
	<target name="download-solr"
		unless="solr.real.location" depends="get-solr-mirror">


		<!-- can't rely on the init target -->
		<mkdir dir="${build.dir}/solr-download/"/>

		<echo>Downloading Solr, please wait...</echo>

		<get src="${solr.mirror}/${solr.version}/apache-solr-${solr.version}-src.tgz" dest="${build.dir}/solr-download/${solr.version}-src.tgz" />
		<untar dest="${build.dir}/solr-download" src="${build.dir}/solr-download/${solr.version}-src.tgz" compression="gzip"/>

		<!-- set the property, it may be used by other targets (see check-solr-location target) -->
		<property name="solr.real.location" value="${build.dir}/solr-download/apache-solr-${solr.version}/solr"/>
	</target>


	<target name="build-solr-example" if="solr.real.location">
		<echo>Building the Solr example</echo>

		<!--
        Unfortunately, the ant task is having some problems with the basedir (ant 1.7)
        <ant target="example"
            dir="${build.dir}/solr-download/apache-solr-${solr.version}/"
            inheritall="false"
        />
        -->

		<exec executable="ant" dir="${solr.real.location}" >
			<env key="PATH" value="${ant.home}/bin${path.separator}${env.PATH}" />
			<arg value="example" />
		</exec>
	</target>


	<target name="try-lucene-jars" depends="check-solr-location" >
		<!-- since on old ant we cannot ignore it -->
		<mkdir dir="${solr.real.location}/dist" />

		<path id="montysolr.classpath.testing">
			<fileset dir="${solr.real.location}/dist" includes="**/*.jar" />
		</path>

		<condition property="lucene.jars.exist" value="true">
			<and>
				<available classname="org.apache.lucene.spatial.tier.InvalidGeoException" classpath="${toString:montysolr.classpath.testing}" />
			</and>
		</condition>

		<echo message="Are lucene jars available? ${lucene.jars.exist}" level="verbose" />
	</target>

	<target name="check-lucene-jars" depends="try-lucene-jars" unless="lucene.jars.exist">
		<delete dir="${solr.real.location}/dist/montysolr-extracted" />
		<mkdir dir="${solr.real.location}/dist/montysolr-extracted" />
		<unzip dest="${solr.real.location}/dist/montysolr-extracted" overwrite="yes">
			<fileset dir="${solr.real.location}/dist">
				<include name="apache-solr*.war" />
			</fileset>
		</unzip>
		<move todir="${solr.real.location}/dist/montysolr-extracted">
			<fileset dir="${solr.real.location}/dist/montysolr-extracted/WEB-INF/lib">
				<include name="**/**.jar"/>
			</fileset>
		</move>
		<delete dir="${solr.real.location}/dist/montysolr-extracted" includeemptydirs="true">
			<exclude name="**/**.jar"/>
		</delete>
	</target>


	<target name="run-example"
	   description="Assembles and runs the example"
	   depends="run-daemon">

	</target>

	<target name="get-solr-mirror" depends="init" >
		<exec executable="${python}" outputproperty="solr.mirror" failonerror="true">
			<arg value="-c" />
			<arg  value="import urllib;t = urllib.urlopen('http://www.apache.org/dyn/closer.cgi/lucene/solr/').read();l = filter(lambda x: 'lucene/solr' in x, map(lambda x: x.split('&quot;')[0], filter(lambda x: x[:4] == 'http', t.split('href=&quot;'))));print l[0]"/>
		</exec>
		<echo>We will use the mirror: ${solr.mirror}</echo>
	</target>

	<target name="install-eclipse-project-files" depends="init" >

		<property name="_home" location="." />

		<exec executable="${python}" failonerror="true" outputproperty="_top_folder">
			<arg value="-c"/>
			<arg value="import os;print os.path.basename(os.path.abspath('.'))" />
		</exec>

		<exec executable="${python}" failonerror="true" outputproperty="_python_ver">
			<arg value="-c"/>
			<arg value="import sys;print '%s.%s' % sys.version_info[:2]" />
		</exec>

		<echo file=".project">
			<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
			<projectDescription>
				<name>]]></echo>
				<echo file=".project" append="true">${_top_folder}</echo>
				<echo file=".project" append="true">
					<![CDATA[</name>
					<comment>
					</comment>
					<projects>
						<project>lucene_solr_3_1</project>
					</projects>
					<buildSpec>
						<buildCommand>
							<name>org.python.pydev.PyDevBuilder</name>
							<arguments>
							</arguments>
						</buildCommand>
						<buildCommand>
							<name>org.eclipse.jdt.core.javabuilder</name>
							<arguments>
							</arguments>
						</buildCommand>
					</buildSpec>
					<natures>
						<nature>org.eclipse.jdt.core.javanature</nature>
						<nature>org.python.pydev.pythonNature</nature>
					</natures>
				</projectDescription>
		   ]]> </echo>

			<echo file=".pydevproject">
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;?eclipse-pydev version="1.0"?&gt;

&lt;pydev_project&gt;
    &lt;pydev_property name="org.python.pydev.PYTHON_PROJECT_INTERPRETER"&gt;Default&lt;/pydev_property&gt;
    &lt;pydev_property name="org.python.pydev.PYTHON_PROJECT_VERSION"&gt;python ${_python_ver}&lt;/pydev_property&gt;
    &lt;pydev_pathproperty name="org.python.pydev.PROJECT_SOURCE_PATH"&gt;
    &lt;path&gt;/${_top_folder}/src/python&lt;/path&gt;
    &lt;/pydev_pathproperty&gt;
    &lt;pydev_pathproperty name="org.python.pydev.PROJECT_EXTERNAL_SOURCE_PATH"&gt;
    &lt;path&gt;${_home}/build/dist&lt;/path&gt;
    &lt;/pydev_pathproperty&gt;
&lt;/pydev_project&gt;
	   </echo>

			<echo file=".classpath">
				<![CDATA[
<?xml version="1.0" encoding="UTF-8"?>
				<classpath>
					<classpathentry kind="src" path="src/java"/>
					<classpathentry kind="src" path="test/java"/>
					<classpathentry kind="lib" path="lib/junit-3.8.2.jar"/>
					<classpathentry kind="lib" path="lib/jzlib-1.0.7.jar"/>
					<classpathentry kind="lib" path="lib/commons-io-1.4.jar"/>
					<classpathentry kind="lib" path="lib/slf4j-api-1.5.5.jar"/>
					<classpathentry kind="lib" path="lib/slf4j-jdk14-1.5.5.jar"/>
					<classpathentry kind="lib" path="]]></echo>
	    <echo file=".classpath" append="true">${jcc_egg}/jcc/classes</echo>
		<echo file=".classpath" append="true"><![CDATA["/>
					<classpathentry combineaccessrules="false" kind="src" path="/lucene_solr_3_1"/>
					<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
					<classpathentry combineaccessrules="false" kind="src" path="/jetty-6.1.4"/>
					<classpathentry kind="output" path="bin"/>
				</classpath>
            ]]> </echo>


		</target>

	</project>
