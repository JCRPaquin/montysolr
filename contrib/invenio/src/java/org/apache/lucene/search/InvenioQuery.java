package org.apache.lucene.search;

import org.apache.lucene.search.Query;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.Similarity;
import org.apache.lucene.search.TermQuery;
import org.apache.lucene.search.Weight;
import invenio.montysolr.jni.MontySolrVM;

import java.io.IOException;
import java.util.Set;

import org.apache.lucene.index.IndexReader;


/**
 * {@link InvenioQuery} extends {@link Query} by adding ability 
 * to query and retrieve data from the Python process using
 * {@link MontySolrVM}
 * 
 * The real work is done by the {@link InvenioWeight} class,
 * which queries the underlying Python process and returns
 * the doc ids (they will be translated from the Invenio recids
 * into lucene docids) on the fly.
 * 
 * @author rchyla
 *
 */

public class InvenioQuery extends Query {


	private static final long serialVersionUID = -5151676153419588281L;
	
	private float boost = 1.0f; // query boost factor
	protected Query query;
	protected String idField = null;
	protected String searchField = null;
	protected String pythonResponder = null;
	
	public InvenioQuery(Query query, String idField, String searchField) {
		super();
		this.query = query;
		this.idField = idField;
		this.searchField = searchField;
	}
	
	public InvenioQuery(Query query, String idField, String searchField, String pythonResponder) {
		super();
		this.query = query;
		this.idField = idField;
		this.searchField = searchField;
		this.pythonResponder = pythonResponder;
	}

	/**
	 * Sets the boost for this query clause to <code>b</code>. Documents
	 * matching this clause will (in addition to the normal weightings) have
	 * their score multiplied by <code>b</code>.
	 */
	public void setBoost(float b) {
		query.setBoost(b);
	}

	/**
	 * Gets the boost for this clause. Documents matching this clause will (in
	 * addition to the normal weightings) have their score multiplied by
	 * <code>b</code>. The boost is 1.0 by default.
	 */
	public float getBoost() {
		return query.getBoost();
	}

	/**
	 * Expert: Constructs an appropriate Weight implementation for this query.
	 *
	 * <p>
	 * Only implemented by primitive queries, which re-write to themselves.
	 */
	public Weight createWeight(Searcher searcher) throws IOException {

		InvenioWeight w = new InvenioWeight((IndexSearcher) searcher, this, idField);
		if (pythonResponder != null) {
			w.setPythonResponder(pythonResponder);
		}
		return w;
	}

	/**
	 * Expert: Constructs and initializes a Weight for a top-level query.
	 */
	public Weight weight(Searcher searcher) throws IOException {
		Query query = searcher.rewrite(this);
		Weight weight = query.createWeight(searcher);
		float sum = weight.sumOfSquaredWeights();
		float norm = getSimilarity(searcher).queryNorm(sum);
		if (Float.isInfinite(norm) || Float.isNaN(norm))
			norm = 1.0f;
		weight.normalize(norm);
		return weight;
	}

	/**
	 * Expert: called to re-write queries into primitive queries. For example, a
	 * PrefixQuery will be rewritten into a BooleanQuery that consists of
	 * TermQuerys.
	 */
	public Query rewrite(IndexReader reader) throws IOException {
		Query rewritten = query.rewrite(reader);
		if (rewritten != query) {
			InvenioQuery clone = (InvenioQuery) this.clone();
			clone.query = rewritten;
			return clone;
		} else {
			return this;
		}
	}

	/**
	 * Expert: called when re-writing queries under MultiSearcher.
	 *
	 * Create a single query suitable for use by all subsearchers (in 1-1
	 * correspondence with queries). This is an optimization of the OR of all
	 * queries. We handle the common optimization cases of equal queries and
	 * overlapping clauses of boolean OR queries (as generated by
	 * MultiTermQuery.rewrite()). Be careful overriding this method as
	 * queries[0] determines which method will be called and is not necessarily
	 * of the same type as the other queries.
	 */
	public Query combine(Query[] queries) {
		return query.combine(queries);

	}

	/**
	 * Expert: adds all terms occurring in this query to the terms set. Only
	 * works if this query is in its {@link #rewrite rewritten} form.
	 *
	 * @throws UnsupportedOperationException
	 *             if this query is not yet rewritten
	 */
	public void extractTerms(Set terms) {
		query.extractTerms(terms);
	}

	/**
	 * Expert: Returns the Similarity implementation to be used for this query.
	 * Subclasses may override this method to specify their own Similarity
	 * implementation, perhaps one that delegates through that of the Searcher.
	 * By default the Searcher's Similarity implementation is returned.
	 */
	public Similarity getSimilarity(Searcher searcher) {
		return searcher.getSimilarity();
	}

	/** Prints a user-readable version of this query. */
	public String toString(String s) {
		StringBuffer buffer = new StringBuffer();
		buffer.append("<(");
		buffer.append("ints,");
		buffer.append(idField);
		buffer.append(")");
		//buffer.append(query.toString());
		buffer.append(getInvenioQuery());
		buffer.append(">");
		return buffer.toString();
	}

	/** Returns true iff <code>o</code> is equal to this. */
	public boolean equals(Object o) {
		if (o instanceof InvenioQuery) {
			InvenioQuery fq = (InvenioQuery) o;
			return (query.equals(fq.query) && getBoost() == fq.getBoost());
		}
		return false;
	}

	/** Returns a hash code value for this object. */
	public int hashCode() {
		return query.hashCode() ^ Float.floatToRawIntBits(getBoost());
	}

	public String getInvenioQuery() {
		//String qfield = ((TermQuery) query).getTerm().field();
		String qval = ((TermQuery) query).getTerm().text();
		
		if (qval.substring(0, 1).equals("\"/")) {
			qval = qval.substring(1, qval.length()-1);
		}
		
		if (searchField != null) {
			qval = searchField + ":" + qval;
		}
		
		return qval;
	}
	
	public Query getInnerQuery() {
		return query;
	}
}

