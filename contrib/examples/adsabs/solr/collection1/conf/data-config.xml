<dataConfig>
    <dataSource type="AdsDataSource" 
        mongoHost="adszee" 
        mongoPort="27017" 
        mongoDocIdField="bibcode" 
        mongoDBName="solr4ads"
        mongoCollectionName="docs"
        jdbcConfig="" />
    <document>
        <entity name="adsabs"
            pk="bibcode"
            url="${dataimporter.request.url}"
            processor="XPathEntityProcessor"
	        transformer="TemplateTransformer,RegexTransformer,BibstemTransformer,MongoTransformer,FacetHierarchyTransformer"
            forEach="/collection/record"
            flatten="false"
            xsl="data-import.xsl"
            >
        
        <field column="bibcode" 
            xpath="/collection/record/datafield[@tag='970']/subfield[@code='a']" />
        
        <!--  the unique id of each record -->                
        <field column="id" 
            xpath="/collection/record/controlfield[@tag='001']" />
            
        <!--  0xx fields, accompanying metadata -->
        <field column="isbn" 
            xpath="/collection/record/datafield[@tag='020']/subfield[@code='a']" />
        <field column="issn" 
            xpath="/collection/record/datafield[@tag='022']/subfield[@code='a']" />
        <field column="doi" 
            xpath="/collection/record/datafield[@tag='024']/subfield[@code='a']" />
        <field column="identifier" 
            xpath="/collection/record/datafield[@tag='035']/subfield[@code='a']" />
        <field column="lang" 
            xpath="/collection/record/datafield[@tag='041']/subfield[@code='a']" />
        
        <!-- note, setting the column="author" would result in duplication, DIH
             creates two separate fields with the same name and they get merged
             into one field (duplication happens) - use copyField instead -->
        <field column="a_100"        
            xpath="/collection/record/datafield[@tag='100']/subfield[@code='a']" />
        <field column="a_700"        
            xpath="/collection/record/datafield[@tag='700']/subfield[@code='a']" />
        
        
        <!--  normalized author names -->
        <field column="a_100_norm"        
            xpath="/collection/record/datafield[@tag='100']/subfield[@code='b']" />
        <field column="a_700_norm"        
            xpath="/collection/record/datafield[@tag='700']/subfield[@code='b']" />
            
            
        <!-- affiliation, I think should be connected with the author, not separated
            (but we can do some magic in the search) 
            u = affiliation
            m = email
            
            perhaps I can make a separate FieldType which receives the xml
            and picks from it the two values, concatenates them and parses
            together for indexing
            -->
        <field column="aff"        
            xpath="/collection/record/datafield[@tag='100']/subfield[@code='u']" />
        <field column="aff"        
            xpath="/collection/record/datafield[@tag='700']/subfield[@code='u']" />
            
        <field column="email"        
            xpath="/collection/record/datafield[@tag='100']/subfield[@code='m']" />
        <field column="email"        
            xpath="/collection/record/datafield[@tag='700']/subfield[@code='m']" />       

        <!--  245 is the original title, 242 is translation -->
        <field column="title"        
            xpath="/collection/record/datafield[@tag='245']/subfield[@code='a']" />
        <field column="alternate_title"        
            xpath="/collection/record/datafield[@tag='242']/subfield[@code='a']" />
            
        <field column="pubdate" 
            xpath="/collection/record/datafield[@tag='260']/subfield[@code='c']" />
        <field column="pubdate_sort" regex="-" replaceWith="" sourceColName="pubdate"/>
        
        <field column="abstract"        
            xpath="/collection/record/datafield[@tag='520']/subfield[@code='a']" />

        <!--  for copyright we index all subfields into one index:
            $a: Copyright (NR)
	        $b  person or institution imposing the license (NR)
	        $u  URI (NR)
         -->
        <field column="copyright"        
            xpath="/collection/record/datafield[@tag='542']/subfield" /> 
        
        <!--  for theses we also index all subfield
            $b: Degree type (NR)
	        $c: Institution granting degree (NR)
	        $d: Year of degree (NR)
         -->
        <field column="thesis"        
            xpath="/collection/record/datafield[@tag='502']/subfield" />
        
        <!-- we do not distinguist primary/secondary here, if we are to, 
            the xpath will have to test for indicator: 1=Primary, 7=Secondary 
        -->
        <field column="arxiv_class"        
            xpath="/collection/record/datafield[@tag='650']/subfield[@code='a']" />
        
        <field column="facility"        
            xpath="/collection/record/datafield[@tag='693']/subfield[@code='f']" /> 
        <field column="instrument"        
            xpath="/collection/record/datafield[@tag='693']/subfield[@code='i']" /> 
        <field column="telescope"        
            xpath="/collection/record/datafield[@tag='693']/subfield[@code='t']" />    
            
        <field column="object"        
            xpath="/collection/record/datafield[@tag='694']/subfield[@code='a']" />
        
        <field column="keyword"        
            xpath="/collection/record/datafield[@tag='653']/subfield[@code='a']" />  <!--  free-text version -->
        <field column="keyword_norm"        
            xpath="/collection/record/datafield[@tag='653']/subfield[@code='b']" />  <!--  normalized version -->
            
        <field column="keyword"        
            xpath="/collection/record/datafield[@tag='695']/subfield[@code='a']" />
        <field column="keyword_norm"        
            xpath="/collection/record/datafield[@tag='695']/subfield[@code='b']" />  <!--  normalized version -->
            
        <field column="collaboration"        
            xpath="/collection/record/datafield[@tag='710']/subfield[@code='t']" />

        <!--  journal info -->
        <field column="pub"        
            xpath="/collection/record/datafield[@tag='773']/subfield[@code='p']" />
        <field column="pub_raw"        
            xpath="/collection/record/datafield[@tag='773']/subfield[@code='z']" />

        <field column="page"        
            xpath="/collection/record/datafield[@tag='773']/subfield[@code='c']" />
        <field column="page"        
            xpath="/collection/record/datafield[@tag='773']/subfield[@code='i']" />

        <field column="issue"        
            xpath="/collection/record/datafield[@tag='773']/subfield[@code='n']" />    
        <field column="volume"        
            xpath="/collection/record/datafield[@tag='773']/subfield[@code='v']" />
        <field column="year"        
            xpath="/collection/record/datafield[@tag='773']/subfield[@code='y']" />    
        
        <!--  record date-stamps -->
        <field column="created"        
            xpath="/collection/record/datafield[@tag='961']/subfield[@code='x']" />

        <field column="modified"        
            xpath="/collection/record/datafield[@tag='961']/subfield[@code='c']" />
        
        <field column="property"
            xpath="/collection/record/datafield[@tag='980']/subfield[@code='p']"/>
            
        <field column="database"
            xpath="/collection/record/datafield[@tag='980']/subfield[@code='a']"/>
            
        <field column="bibgroup"
            xpath="/collection/record/datafield[@tag='980']/subfield[@code='b']"/>
        
        <field column="data"
            xpath="/collection/record/datafield[@tag='980']/subfield[@code='s']"/>
        
        <field column="vizier"
            xpath="/collection/record/datafield[@tag='980']/subfield[@code='v']"/>
        
        <!--  this is not a timestamp, but st like a signature of a records extracted
              from ADS (maybe can be useful for comparing imports) -->
        <!--  switching it off until needed, it is very technical data
        <field column="stamp"        
            xpath="/collection/record/datafield[@tag='995']/subfield[@code='a']" />
         -->
        
        <field column="reference"        
            xpath="/collection/record/datafield[@tag='999']/subfield[@code='i']" />
            
        <!--  for indexing, we put all field inside the reference index, and also build a special index for 
              the individual subfields -->
        <!-- 
        <field column="reference_doi"        
            xpath="/collection/record/datafield[@tag='999']/subfield[@code='a']" />
        <field column="reference_raw"        
            xpath="/collection/record/datafield[@tag='999']/subfield[@code='b']" />
            
        <field column="ref_doi"        
            xpath="/collection/record/datafield[@tag='999']/subfield[@code='a']" />
        <field column="ref_string"        
            xpath="/collection/record/datafield[@tag='999']/subfield[@code='b']" />
        <field column="ref_score"        
            xpath="/collection/record/datafield[@tag='999']/subfield[@code='e']" />
        <field column="ref_source"        
            xpath="/collection/record/datafield[@tag='999']/subfield[@code='f']" />
        <field column="ref_bibcode"        
            xpath="/collection/record/datafield[@tag='999']/subfield[@code='i']" />
        <field column="ref_arxivid"        
            xpath="/collection/record/datafield[@tag='999']/subfield[@code='r']" />    
        --> 
        <!-- field column="entdate" xpath="" / -->
        <!-- field column="bibgroup" xpath="" / -->
            
        <field column="full" mongoField="true"/>
        
        <field column="ack" mongoField="true"/>
        
        <field column="reader" mongoField="true" mongoFieldName="readers"/>

        <field column="cite_read_boost" mongoField="true" />
        <field column="citation_count" mongoField="true" />
        <field column="read_count" mongoField="true" mongoFieldName="norm_read_count" />
        
        <!-- 
            Fields marked as facetHierarchyField will be processed by the FacetHierarchyTransformer.
            "column" indicates the new column that will be created based on the values in "fields".
            the hierarchy will be constructed in the order the "fields" are listed.
            multiValuedSource="true" is necessary if the source "fields" are multiValued.
            Because the transformer inserts an array of values for the hierarchical facet,
            the "column" must be configured as multiValued="true" in schema.xml
         -->
        <field facetHierarchyField="true" column="author_facet_hier" fields="a_100_norm,a_100,a_700_norm,a_700" multiValuedSource="true" />
        <field facetHierarchyField="true" column="first_author_facet_hier" fields="a_100_norm,a_100" multiValuedSource="true" />
        
        </entity>
        
    </document>
</dataConfig>
